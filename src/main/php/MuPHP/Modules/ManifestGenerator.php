<?php

declare(strict_types=1);
/**
 * Copyright 2018 Andrew O'Rourke
 */

namespace MuPHP\Modules;

/**
 * Class Modules
 * @package Modules
 *
 * Is responsible for handling the loading of modules
 */
class ManifestGenerator
{
    const MANIFEST_FILENAME = 'vendor/modules.php';
    const DISALLOWED_FOLDERS = ['.', '..', 'test', 'tests', 'logs'];

    /**
     * This method generates the manifest and dumps it into a file
     *
     * @param string $filename Optional. Specifies the explicit filename.
     */
    public static function dumpManifestToFile(
        $filename = self::MANIFEST_FILENAME
    ): void {
        $categories = self::generateManifest();

        $phpOutput = "<?php\n// modules.php @generated by Modules\n\n";
        $payload = serialize($categories);
        $phpOutput .= 'return unserialize(' . PHP_EOL . '    \'';
        $chunks = str_split($payload, 70);
        $phpOutput .= implode("' . " . PHP_EOL . "    '", $chunks);
        $phpOutput .= '\');' . PHP_EOL;

        file_put_contents(
            $filename,
            $phpOutput
        );
    }

    /**
     * This method is meant to be invoked by Composer whenever the packages are
     * updated. It discovers and generates a manifest of all the modules.
     *
     * @var $path string Path to search from. Should be the root of the project.
     * @return array The modules manifest.
     */
    public static function generateManifest(string $path = '.'): array
    {
        $moduleContainers = self::recursiveSearch($path);
        $modules = [];

        foreach ($moduleContainers as $moduleContainer) {
            foreach ($moduleContainer->getModules() as $module) {
                $modules[$module->getName()]
                [$moduleContainer->getFullyQualifiedClassName()] =
                    $moduleContainer;
            }
        }

        return $modules;
    }

    private static function recursiveSearch($folderName): array
    {
        $results = [];
        $dir = new \DirectoryIterator($folderName);
        foreach ($dir as $file) {
            if ($file->isFile() && $file->getExtension() == 'php') {
                $result = self::findModules($file->getPathname());
                if (!is_null($result)) {
                    $results[] = $result;
                }
            } elseif ($file->isDir()) {
                if (!in_array(
                    $file->getFilename(),
                    self::DISALLOWED_FOLDERS
                )) {
                    $nested = self::recursiveSearch($file->getPathname());
                    $results = array_merge($results, $nested);
                }
            }
        }
        return $results;
    }

    private static function findModules(string $filePathname)
    {
        $matches = [];
        $source = file_get_contents($filePathname);
        preg_match_all(
            '/@@([\w\d]+)( +[^\n]+)?(?=\n[^{]*\/\s+class\s+\w+\s+{)/',
            $source,
            $matches,
            PREG_SET_ORDER
        );

        if (count($matches) > 0) {
            $classMatches = [];
            preg_match(
                '/namespace\s+(\S+)\s*;[^{]+class\s+(\S+)/',
                $source,
                $classMatches
            );

            if (count($classMatches) != 3) {
                return null;
            }

            $namespace = $classMatches[1];
            $className = $classMatches[2];

            $modules = [];

            foreach ($matches as $match) {
                if (count($match) == 3) {
                    $modules[] = self::parseModule($match[1], trim($match[2]));
                } else {
                    $modules[] = self::parseModule($match[1]);
                }
            }
            return new ModuleContainer(
                $namespace,
                $modules,
                $className
            );
        } else {
            return null;
        }
    }

    private static function parseModule(
        string $moduleName,
        string $parameters = null
    ): Module {
        if ($parameters == null) {
            return new Module($moduleName);
        }
        preg_match_all(
            '/(\w[\w\d]+)\s*=\s*((?:\'[^\']+\')|(?:"[^"]+")|(?:\S+))/',
            trim($parameters),
            $entries,
            PREG_SET_ORDER
        );

        $variables = [];
        foreach ($entries as $entry) {
            $variables[$entry[1]] = trim($entry[2], ' "\'');
        }
        return new Module($moduleName, $variables);
    }
}
